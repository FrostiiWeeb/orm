{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ORM The orm package is an async ORM for Python, with support for Postgres, MySQL, and SQLite. ORM is built with: SQLAlchemy core for query building. databases for cross-database async support. typesystem for data validation. Because ORM is built on SQLAlchemy core, you can use Alembic to provide database migrations. ORM is still under development: We recommend pinning any dependencies with orm~=0.2 Installation $ pip install orm You can install the required database drivers with: $ pip install orm [ postgresql ] $ pip install orm [ mysql ] $ pip install orm [ sqlite ] Driver support is provided using one of asyncpg , aiomysql , or aiosqlite . Quickstart Note : Use ipython to try this from the console, since it supports await . import databases import orm database = databases . Database ( \"sqlite:///db.sqlite\" ) models = orm . ModelRegistry ( database = database ) class Note ( orm . Model ): tablename = \"notes\" registry = models fields = { \"id\" : orm . Integer ( primary_key = True ), \"text\" : orm . String ( max_length = 100 ), \"completed\" : orm . Boolean ( default = False ), } # Create the database and tables await models . create_all () await Note . objects . create ( text = \"Buy the groceries.\" , completed = False ) note = await Note . objects . get ( id = 1 ) print ( note ) # Note(id=1)","title":"Introduction"},{"location":"#orm","text":"The orm package is an async ORM for Python, with support for Postgres, MySQL, and SQLite. ORM is built with: SQLAlchemy core for query building. databases for cross-database async support. typesystem for data validation. Because ORM is built on SQLAlchemy core, you can use Alembic to provide database migrations. ORM is still under development: We recommend pinning any dependencies with orm~=0.2","title":"ORM"},{"location":"#installation","text":"$ pip install orm You can install the required database drivers with: $ pip install orm [ postgresql ] $ pip install orm [ mysql ] $ pip install orm [ sqlite ] Driver support is provided using one of asyncpg , aiomysql , or aiosqlite .","title":"Installation"},{"location":"#quickstart","text":"Note : Use ipython to try this from the console, since it supports await . import databases import orm database = databases . Database ( \"sqlite:///db.sqlite\" ) models = orm . ModelRegistry ( database = database ) class Note ( orm . Model ): tablename = \"notes\" registry = models fields = { \"id\" : orm . Integer ( primary_key = True ), \"text\" : orm . String ( max_length = 100 ), \"completed\" : orm . Boolean ( default = False ), } # Create the database and tables await models . create_all () await Note . objects . create ( text = \"Buy the groceries.\" , completed = False ) note = await Note . objects . get ( id = 1 ) print ( note ) # Note(id=1)","title":"Quickstart"},{"location":"declaring_models/","text":"Declaring models You can define models by inheriting from orm.Model and defining model fields in the fields attribute. For each defined model you need to set two special variables: registry an instance of orm.ModelRegistry fields a dict of orm fields You can also specify the table name in database by setting tablename attribute. import databases import orm database = databases . Database ( \"sqlite:///db.sqlite\" ) models = orm . ModelRegistry ( database = database ) class Note ( orm . Model ): tablename = \"notes\" registry = models fields = { \"id\" : orm . Integer ( primary_key = True ), \"text\" : orm . String ( max_length = 100 ), \"completed\" : orm . Boolean ( default = False ), } ORM can create or drop database and tables from models using SQLAlchemy. You can use the following methods: await models . create_all () await models . drop_all () Data types The following keyword arguments are supported on all field types. primary_key - A boolean. Determine if column is primary key. allow_null - A boolean. Determine if column is nullable. default - A value or a callable (function). index - A boolean. Determine if database indexes should be created. unique - A boolean. Determine if unique constraint should be created. All fields are required unless one of the following is set: allow_null - A boolean. Determine if column is nullable. Sets the default to None . allow_blank - A boolean. Determine if empty strings are allowed. Sets the default to \"\" . default - A value or a callable (function). The following column types are supported. See TypeSystem for type-specific validation keyword arguments . orm.BigInteger() orm.Boolean() orm.Date() orm.DateTime() orm.Decimal() orm.Email(max_length) orm.Enum() orm.Float() orm.Integer() orm.IPAddress() orm.String(max_length) orm.Text() orm.Time() orm.URL(max_length) orm.UUID() orm.JSON()","title":"Declaring Models"},{"location":"declaring_models/#declaring-models","text":"You can define models by inheriting from orm.Model and defining model fields in the fields attribute. For each defined model you need to set two special variables: registry an instance of orm.ModelRegistry fields a dict of orm fields You can also specify the table name in database by setting tablename attribute. import databases import orm database = databases . Database ( \"sqlite:///db.sqlite\" ) models = orm . ModelRegistry ( database = database ) class Note ( orm . Model ): tablename = \"notes\" registry = models fields = { \"id\" : orm . Integer ( primary_key = True ), \"text\" : orm . String ( max_length = 100 ), \"completed\" : orm . Boolean ( default = False ), } ORM can create or drop database and tables from models using SQLAlchemy. You can use the following methods: await models . create_all () await models . drop_all ()","title":"Declaring models"},{"location":"declaring_models/#data-types","text":"The following keyword arguments are supported on all field types. primary_key - A boolean. Determine if column is primary key. allow_null - A boolean. Determine if column is nullable. default - A value or a callable (function). index - A boolean. Determine if database indexes should be created. unique - A boolean. Determine if unique constraint should be created. All fields are required unless one of the following is set: allow_null - A boolean. Determine if column is nullable. Sets the default to None . allow_blank - A boolean. Determine if empty strings are allowed. Sets the default to \"\" . default - A value or a callable (function). The following column types are supported. See TypeSystem for type-specific validation keyword arguments . orm.BigInteger() orm.Boolean() orm.Date() orm.DateTime() orm.Decimal() orm.Email(max_length) orm.Enum() orm.Float() orm.Integer() orm.IPAddress() orm.String(max_length) orm.Text() orm.Time() orm.URL(max_length) orm.UUID() orm.JSON()","title":"Data types"},{"location":"making_queries/","text":"Let's say you have the following model defined: import databases import orm database = databases . Database ( \"sqlite:///db.sqlite\" ) models = orm . ModelRegistry ( database = database ) class Note ( orm . Model ): tablename = \"notes\" registry = models fields = { \"id\" : orm . Integer ( primary_key = True ), \"text\" : orm . String ( max_length = 100 ), \"completed\" : orm . Boolean ( default = False ), } ORM supports two types of queryset methods. Some queryset methods return another queryset and can be chianed together like .filter() and order_by : Note . objects . filter ( completed = True ) . order_by ( \"id\" ) Other queryset methods return results and should be used as final method on the queryset like .all() : Note . objects . filter ( completed = True ) . all () Returning Querysets .exclude() To exclude instances: notes = await Note . objects . exclude ( completed = False ) . all () .filter() Django-style lookup To filter instances: notes = await Note . objects . filter ( completed = True ) . all () There are some special operators defined automatically on every column: in - SQL IN operator. exact - filter instances matching exact value. iexact - same as exact but case-insensitive. contains - filter instances containing value. icontains - same as contains but case-insensitive. lt - filter instances having value Less Than . lte - filter instances having value Less Than Equal . gt - filter instances having value Greater Than . gte - filter instances having value Greater Than Equal . Example usage: notes = await Note . objects . filter ( text__icontains = \"mum\" ) . all () notes = await Note . objects . filter ( id__in = [ 1 , 2 , 3 ]) . all () SQLAlchemy filter operators The filter method also accepts SQLAlchemy filter operators: notes = await Note . objects . filter ( Note . columns . text . contains ( \"mum\" )) . all () notes = await Note . objects . filter ( Note . columns . id . in_ ([ 1 , 2 , 3 ])) . all () Here Note.columns refers to the columns of the underlying SQLAlchemy table. Note Note that Note.columns returns SQLAlchemy table columns, whereas Note.fields returns orm fields. .limit() To limit number of results: await Note . objects . limit ( 1 ) . all () .offset() To apply offset to query results: await Note . objects . offset ( 1 ) . all () As mentioned before, you can chain multiple queryset methods together to form a query. As an exmaple: await Note . objects . order_by ( \"id\" ) . limit ( 1 ) . offset ( 1 ) . all () await Note . objects . filter ( text__icontains = \"mum\" ) . limit ( 2 ) . all () .order_by() To order query results: notes = await Note . objects . order_by ( \"text\" , \"-id\" ) . all () Note This will sort by ascending text and descending id . Returning results .all() To retrieve all the instances: notes = await Note . objects . all () .create() You need to pass the required model attributes and values to the .create() method: await Note . objects . create ( text = \"Buy the groceries.\" , completed = False ) await Note . objects . create ( text = \"Call Mum.\" , completed = True ) await Note . objects . create ( text = \"Send invoices.\" , completed = True ) .delete() You can delete instances by calling .delete() on a queryset: await Note . objects . filter ( completed = True ) . delete () It's not very common, but to delete all rows in a table: await Note . objects . delete () You can also call .delete() on a queried instance: note = await Note . objects . first () await note . delete () .exists() To check if any instances matching the query exist. Returns True or False . await Note . objects . filter ( completed = True ) . exists () .first() This will return the first instance or None : note = await Note . objects . filter ( completed = True ) . first () pk always refers to the model's primary key field: note = await Note . objects . get ( pk = 2 ) note . pk # 2 .get() To get only one instance: note = await Note . objects . get ( id = 1 ) Note .get() expects to find only one instance. This can raise NoMatch or MultipleMatches . .update() You can update instances by calling .update() on a queryset: await Note . objects . filter ( completed = True ) . update ( completed = False ) It's not very common, but to update all rows in a table: await Note . objects . update ( completed = False ) You can also call .update() on a queried instance: note = await Note . objects . first () await note . update ( completed = True ) Convenience Methods .get_or_create() To get an existing instance matching the query, or create a new one. This will retuurn a tuple of instance and created . note , created = await Note . objects . get_or_create ( text = \"Going to car wash\" , defaults = { \"completed\" : False } ) This will query a Note with text as \"Going to car wash\" , if it doesn't exist, it will use defaults argument to create the new instance. Note Since get_or_create() is doing a get() , it can raise MultipleMatches exception. .update_or_create() To update an existing instance matching the query, or create a new one. This will retuurn a tuple of instance and created . note , created = await Note . objects . update_or_create ( text = \"Going to car wash\" , defaults = { \"completed\" : True } ) This will query a Note with text as \"Going to car wash\" , if an instance is found, it will use the defaults argument to update the instance. If it matches no records, it will use the comibnation of arguments to create the new instance. Note Since update_or_create() is doing a get() , it can raise MultipleMatches exception.","title":"Making Queries"},{"location":"making_queries/#returning-querysets","text":"","title":"Returning Querysets"},{"location":"making_queries/#exclude","text":"To exclude instances: notes = await Note . objects . exclude ( completed = False ) . all ()","title":".exclude()"},{"location":"making_queries/#filter","text":"","title":".filter()"},{"location":"making_queries/#django-style-lookup","text":"To filter instances: notes = await Note . objects . filter ( completed = True ) . all () There are some special operators defined automatically on every column: in - SQL IN operator. exact - filter instances matching exact value. iexact - same as exact but case-insensitive. contains - filter instances containing value. icontains - same as contains but case-insensitive. lt - filter instances having value Less Than . lte - filter instances having value Less Than Equal . gt - filter instances having value Greater Than . gte - filter instances having value Greater Than Equal . Example usage: notes = await Note . objects . filter ( text__icontains = \"mum\" ) . all () notes = await Note . objects . filter ( id__in = [ 1 , 2 , 3 ]) . all ()","title":"Django-style lookup"},{"location":"making_queries/#sqlalchemy-filter-operators","text":"The filter method also accepts SQLAlchemy filter operators: notes = await Note . objects . filter ( Note . columns . text . contains ( \"mum\" )) . all () notes = await Note . objects . filter ( Note . columns . id . in_ ([ 1 , 2 , 3 ])) . all () Here Note.columns refers to the columns of the underlying SQLAlchemy table. Note Note that Note.columns returns SQLAlchemy table columns, whereas Note.fields returns orm fields.","title":"SQLAlchemy filter operators"},{"location":"making_queries/#limit","text":"To limit number of results: await Note . objects . limit ( 1 ) . all ()","title":".limit()"},{"location":"making_queries/#offset","text":"To apply offset to query results: await Note . objects . offset ( 1 ) . all () As mentioned before, you can chain multiple queryset methods together to form a query. As an exmaple: await Note . objects . order_by ( \"id\" ) . limit ( 1 ) . offset ( 1 ) . all () await Note . objects . filter ( text__icontains = \"mum\" ) . limit ( 2 ) . all ()","title":".offset()"},{"location":"making_queries/#order_by","text":"To order query results: notes = await Note . objects . order_by ( \"text\" , \"-id\" ) . all () Note This will sort by ascending text and descending id .","title":".order_by()"},{"location":"making_queries/#returning-results","text":"","title":"Returning results"},{"location":"making_queries/#all","text":"To retrieve all the instances: notes = await Note . objects . all ()","title":".all()"},{"location":"making_queries/#create","text":"You need to pass the required model attributes and values to the .create() method: await Note . objects . create ( text = \"Buy the groceries.\" , completed = False ) await Note . objects . create ( text = \"Call Mum.\" , completed = True ) await Note . objects . create ( text = \"Send invoices.\" , completed = True )","title":".create()"},{"location":"making_queries/#delete","text":"You can delete instances by calling .delete() on a queryset: await Note . objects . filter ( completed = True ) . delete () It's not very common, but to delete all rows in a table: await Note . objects . delete () You can also call .delete() on a queried instance: note = await Note . objects . first () await note . delete ()","title":".delete()"},{"location":"making_queries/#exists","text":"To check if any instances matching the query exist. Returns True or False . await Note . objects . filter ( completed = True ) . exists ()","title":".exists()"},{"location":"making_queries/#first","text":"This will return the first instance or None : note = await Note . objects . filter ( completed = True ) . first () pk always refers to the model's primary key field: note = await Note . objects . get ( pk = 2 ) note . pk # 2","title":".first()"},{"location":"making_queries/#get","text":"To get only one instance: note = await Note . objects . get ( id = 1 ) Note .get() expects to find only one instance. This can raise NoMatch or MultipleMatches .","title":".get()"},{"location":"making_queries/#update","text":"You can update instances by calling .update() on a queryset: await Note . objects . filter ( completed = True ) . update ( completed = False ) It's not very common, but to update all rows in a table: await Note . objects . update ( completed = False ) You can also call .update() on a queried instance: note = await Note . objects . first () await note . update ( completed = True )","title":".update()"},{"location":"making_queries/#convenience-methods","text":"","title":"Convenience Methods"},{"location":"making_queries/#get_or_create","text":"To get an existing instance matching the query, or create a new one. This will retuurn a tuple of instance and created . note , created = await Note . objects . get_or_create ( text = \"Going to car wash\" , defaults = { \"completed\" : False } ) This will query a Note with text as \"Going to car wash\" , if it doesn't exist, it will use defaults argument to create the new instance. Note Since get_or_create() is doing a get() , it can raise MultipleMatches exception.","title":".get_or_create()"},{"location":"making_queries/#update_or_create","text":"To update an existing instance matching the query, or create a new one. This will retuurn a tuple of instance and created . note , created = await Note . objects . update_or_create ( text = \"Going to car wash\" , defaults = { \"completed\" : True } ) This will query a Note with text as \"Going to car wash\" , if an instance is found, it will use the defaults argument to update the instance. If it matches no records, it will use the comibnation of arguments to create the new instance. Note Since update_or_create() is doing a get() , it can raise MultipleMatches exception.","title":".update_or_create()"},{"location":"relationships/","text":"ForeignKey Defining and querying relationships ORM supports loading and filtering across foreign keys. Let's say you have the following models defined: import databases import orm database = databases . Database ( \"sqlite:///db.sqlite\" ) models = orm . ModelRegistry ( database = database ) class Album ( orm . Model ): tablename = \"albums\" registry = models fields = { \"id\" : orm . Integer ( primary_key = True ), \"name\" : orm . String ( max_length = 100 ), } class Track ( orm . Model ): tablename = \"tracks\" registry = models fields = { \"id\" : orm . Integer ( primary_key = True ), \"album\" : orm . ForeignKey ( Album ), \"title\" : orm . String ( max_length = 100 ), \"position\" : orm . Integer (), } You can create some Album and Track instances: malibu = await Album . objects . create ( name = \"Malibu\" ) await Track . objects . create ( album = malibu , title = \"The Bird\" , position = 1 ) await Track . objects . create ( album = malibu , title = \"Heart don't stand a chance\" , position = 2 ) await Track . objects . create ( album = malibu , title = \"The Waters\" , position = 3 ) fantasies = await Album . objects . create ( name = \"Fantasies\" ) await Track . objects . create ( album = fantasies , title = \"Help I'm Alive\" , position = 1 ) await Track . objects . create ( album = fantasies , title = \"Sick Muse\" , position = 2 ) To fetch an instance, without loading a foreign key relationship on it: track = await Track . objects . get ( title = \"The Bird\" ) # We have an album instance, but it only has the primary key populated print ( track . album ) # Album(id=1) [sparse] print ( track . album . pk ) # 1 print ( track . album . name ) # Raises AttributeError You can load the relationship from the database: await track . album . load () assert track . album . name == \"Malibu\" You can also fetch an instance, loading the foreign key relationship with it: track = await Track . objects . select_related ( \"album\" ) . get ( title = \"The Bird\" ) assert track . album . name == \"Malibu\" To fetch an instance, filtering across a foregin key relationship: tracks = Track . objects . filter ( album__name = \"Fantasies\" ) assert len ( tracks ) == 2 tracks = Track . objects . filter ( album__name__iexact = \"fantasies\" ) assert len ( tracks ) == 2 ForeignKey constraints ForeigknKey supports specfiying a constraint through on_delete argument. This will result in a SQL ON DELETE query being generated when the referenced object is removed. With the following definition: class Album ( orm . Model ): tablename = \"albums\" registry = models fields = { \"id\" : orm . Integer ( primary_key = True ), \"name\" : orm . String ( max_length = 100 ), } class Track ( orm . Model ): tablename = \"tracks\" registry = models fields = { \"id\" : orm . Integer ( primary_key = True ), \"album\" : orm . ForeignKey ( Album , on_delete = orm . CASCADE ), \"title\" : orm . String ( max_length = 100 ), } Track model defines orm.ForeignKey(Album, on_delete=orm.CASCADE) so whenever an Album object is removed, all Track objects referencing that Album will also be removed. Available options for on_delete are: CASCADE This will remove all referencing objects. RESTRICT This will restrict removing referenced object, if there are objects referencing it. A database driver exception will be raised. SET NULL This will set referencing objects ForeignKey column to NULL . The ForeignKey defined here should also have allow_null=True . OneToOne Creating a OneToOne relationship between models, this is basically the same as ForeignKey but it uses unique=True on the ForeignKey column: class Profile ( orm . Model ): registry = models fields = { \"id\" : orm . Integer ( primary_key = True ), \"website\" : orm . String ( max_length = 100 ), } class Person ( orm . Model ): registry = models fields = { \"id\" : orm . Integer ( primary_key = True ), \"email\" : orm . String ( max_length = 100 ), \"profile\" : orm . OneToOne ( Profile ), } You can create a Profile and Person instance: profile = await Profile . objects . create ( website = \"https://encode.io\" ) await Person . objects . create ( email = \"info@encode.io\" , profile = profile ) Now creating another Person using the same profile will fail and will raise an exception: await Person . objects . create ( email = \"info@encode.io\" , profile = profile ) OneToOne accepts the same on_delete parameters as ForeignKey which is described here .","title":"Relationships"},{"location":"relationships/#foreignkey","text":"","title":"ForeignKey"},{"location":"relationships/#defining-and-querying-relationships","text":"ORM supports loading and filtering across foreign keys. Let's say you have the following models defined: import databases import orm database = databases . Database ( \"sqlite:///db.sqlite\" ) models = orm . ModelRegistry ( database = database ) class Album ( orm . Model ): tablename = \"albums\" registry = models fields = { \"id\" : orm . Integer ( primary_key = True ), \"name\" : orm . String ( max_length = 100 ), } class Track ( orm . Model ): tablename = \"tracks\" registry = models fields = { \"id\" : orm . Integer ( primary_key = True ), \"album\" : orm . ForeignKey ( Album ), \"title\" : orm . String ( max_length = 100 ), \"position\" : orm . Integer (), } You can create some Album and Track instances: malibu = await Album . objects . create ( name = \"Malibu\" ) await Track . objects . create ( album = malibu , title = \"The Bird\" , position = 1 ) await Track . objects . create ( album = malibu , title = \"Heart don't stand a chance\" , position = 2 ) await Track . objects . create ( album = malibu , title = \"The Waters\" , position = 3 ) fantasies = await Album . objects . create ( name = \"Fantasies\" ) await Track . objects . create ( album = fantasies , title = \"Help I'm Alive\" , position = 1 ) await Track . objects . create ( album = fantasies , title = \"Sick Muse\" , position = 2 ) To fetch an instance, without loading a foreign key relationship on it: track = await Track . objects . get ( title = \"The Bird\" ) # We have an album instance, but it only has the primary key populated print ( track . album ) # Album(id=1) [sparse] print ( track . album . pk ) # 1 print ( track . album . name ) # Raises AttributeError You can load the relationship from the database: await track . album . load () assert track . album . name == \"Malibu\" You can also fetch an instance, loading the foreign key relationship with it: track = await Track . objects . select_related ( \"album\" ) . get ( title = \"The Bird\" ) assert track . album . name == \"Malibu\" To fetch an instance, filtering across a foregin key relationship: tracks = Track . objects . filter ( album__name = \"Fantasies\" ) assert len ( tracks ) == 2 tracks = Track . objects . filter ( album__name__iexact = \"fantasies\" ) assert len ( tracks ) == 2","title":"Defining and querying relationships"},{"location":"relationships/#foreignkey-constraints","text":"ForeigknKey supports specfiying a constraint through on_delete argument. This will result in a SQL ON DELETE query being generated when the referenced object is removed. With the following definition: class Album ( orm . Model ): tablename = \"albums\" registry = models fields = { \"id\" : orm . Integer ( primary_key = True ), \"name\" : orm . String ( max_length = 100 ), } class Track ( orm . Model ): tablename = \"tracks\" registry = models fields = { \"id\" : orm . Integer ( primary_key = True ), \"album\" : orm . ForeignKey ( Album , on_delete = orm . CASCADE ), \"title\" : orm . String ( max_length = 100 ), } Track model defines orm.ForeignKey(Album, on_delete=orm.CASCADE) so whenever an Album object is removed, all Track objects referencing that Album will also be removed. Available options for on_delete are: CASCADE This will remove all referencing objects. RESTRICT This will restrict removing referenced object, if there are objects referencing it. A database driver exception will be raised. SET NULL This will set referencing objects ForeignKey column to NULL . The ForeignKey defined here should also have allow_null=True .","title":"ForeignKey constraints"},{"location":"relationships/#onetoone","text":"Creating a OneToOne relationship between models, this is basically the same as ForeignKey but it uses unique=True on the ForeignKey column: class Profile ( orm . Model ): registry = models fields = { \"id\" : orm . Integer ( primary_key = True ), \"website\" : orm . String ( max_length = 100 ), } class Person ( orm . Model ): registry = models fields = { \"id\" : orm . Integer ( primary_key = True ), \"email\" : orm . String ( max_length = 100 ), \"profile\" : orm . OneToOne ( Profile ), } You can create a Profile and Person instance: profile = await Profile . objects . create ( website = \"https://encode.io\" ) await Person . objects . create ( email = \"info@encode.io\" , profile = profile ) Now creating another Person using the same profile will fail and will raise an exception: await Person . objects . create ( email = \"info@encode.io\" , profile = profile ) OneToOne accepts the same on_delete parameters as ForeignKey which is described here .","title":"OneToOne"}]}